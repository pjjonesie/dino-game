<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dino</title>
  <link rel="stylesheet" href="index.css" />
</head>

<body>
  <!-- Outer container Runner expects -->
  <div id="main-frame-error" class="interstitial-wrapper">
    <!-- Minimal bits Runner may look for -->
    <button id="details-button" aria-hidden="true" tabindex="-1" style="display:none"></button>

    <!-- Where the game injects its canvas -->
    <div id="runner-container" class="runner-container"></div>
  </div>

  <!-- Overlay -->
  <div id="messageBox">
    <h1>Press Space to Start</h1>
  </div>

  <!-- Game logic -->
  <script src="index.js"></script>

  <script>
    /* Hide overlay on Space WITHOUT breaking the game's own handlers */
    window.addEventListener("keydown", (evt) => {
      if (evt.code === "Space" || evt.keyCode === 32) {
        const box = document.getElementById("messageBox");
        if (box) box.style.visibility = "hidden";
        // Don't preventDefault â€” let the game receive Space.
      }
    }, { passive: true });

    /* Start the Runner safely (wait until Runner exists + DOM is ready) */
    (function startRunnerWhenReady() {
      const outerSelector = "#main-frame-error";

      function tryStart() {
        if (!window.Runner) return false;
        const outer = document.querySelector(outerSelector);
        if (!outer) return false;

        try {
          // Only start once
          if (!window.__PJ_DINO_RUNNER__) {
            window.__PJ_DINO_RUNNER__ = new window.Runner(outerSelector);
          }
          return true;
        } catch (e) {
          // If it throws, keep trying a few times in case assets/init timing
          console.error("Runner init error:", e);
          return false;
        }
      }

      let attempts = 0;
      const t = setInterval(() => {
        attempts++;
        if (tryStart() || attempts > 120) clearInterval(t);
      }, 50);
    })();

    /* Full-bleed cover scaling (NO squish) */
    (function fullBleedCover() {
      function fit() {
        const c = document.querySelector("canvas");
        if (!c) return;

        const baseW = c.width || 600;
        const baseH = c.height || 150;

        const vw = window.innerWidth;
        const vh = window.innerHeight;

        // cover scale like object-fit: cover
        const scale = Math.max(vw / baseW, vh / baseH);

        c.style.position = "fixed";
        c.style.left = "50%";
        c.style.top = "50%";
        c.style.transformOrigin = "center center";
        c.style.transform = `translate(-50%, -50%) scale(${scale})`;
      }

      window.addEventListener("resize", fit, { passive: true });

      let tries = 0;
      const t = setInterval(() => {
        fit();
        if (++tries > 160) clearInterval(t);
      }, 50);
    })();

    /* Font patch (Score / HI / GAME OVER) */
    (function fontPatch() {
      const FONT = '900 28px "Arial Black", Arial, sans-serif';
      const BIGFONT = '900 46px "Arial Black", Arial, sans-serif';
      const CONDENSE = 0.84;

      function shouldStyleText(txt) {
        if (txt == null) return false;
        const s = String(txt).trim();
        if (/^\d+$/.test(s)) return true;          // score digits
        if (/^HI\s*\d+/i.test(s)) return true;     // HI ######
        if (/GAME\s*OVER/i.test(s)) return true;   // GAME OVER
        return false;
      }

      const proto = CanvasRenderingContext2D.prototype;
      if (proto.__pjFontPatched) return;
      proto.__pjFontPatched = true;

      const original = proto.fillText;

      proto.fillText = function(text, x, y, maxWidth) {
        if (!shouldStyleText(text)) {
          return original.call(this, text, x, y, maxWidth);
        }

        const s = String(text);
        const big = /GAME\s*OVER/i.test(s);

        const prevFont = this.font;
        const prevFill = this.fillStyle;

        this.save();
        this.scale(CONDENSE, 1);

        const newX = x / CONDENSE;

        this.font = big ? BIGFONT : FONT;
        this.fillStyle = "#000";

        const out = original.call(this, s, newX, y, maxWidth);

        this.restore();
        this.font = prevFont;
        this.fillStyle = prevFill;

        return out;
      };
    })();
  </script>
</body>
</html>



